import java.util.*;

class Node {
    int data;
    Node left, right;

    public Node(int data) {
        this.data = data;
        this.left = this.right = null;
    }
}

class BinaryTree {
    Node root;

    //NOVO NÓ
    void insert(int data) {
        root = insertRec(root, data);
    }

    Node insertRec(Node root, int data) {
        if (root == null) {
            root = new Node(data);
            return root;
        }

        if (data < root.data)
            root.left = insertRec(root.left, data);
        else if (data > root.data)
            root.right = insertRec(root.right, data);

        return root;
    }

    //DSW
    void createBalancedTree() {
        Node curr = root;
        createBackbone(curr);

        int n = 0;
        for (int m = size(); m > 1; m = m / 2) {
            n++;
        }
        int leaves = size() + 1 - (int) Math.pow(2, n);

        createPerfectTree(leaves);
    }

    void createBackbone(Node curr) {
        Node grandParent = null;
        Node parent = null;
        Node pred = null;

        while (curr != null) {
            if (curr.left != null) {
                // Rotate right
                Node temp = curr.left;
                curr.left = temp.right;
                temp.right = curr;
                curr = temp;

                if (parent != null)
                    parent.right = curr;
                else
                    root = curr;

                grandParent = parent;
                parent = curr;
                curr = curr.right;
            } else {
                pred = curr;
                curr = curr.right;

                if (grandParent != null && pred != null) {
                    grandParent.right = pred;
                    grandParent = grandParent.right;
                }
            }
        }
    }

    void createPerfectTree(int leaves) {
        int m = 2 * leaves - 1;
        Node curr = root;

        for (int i = 0; i < m && curr != null; i++) {
            if ((i < leaves - 1) || (i % 2 == 0)) {
                curr = rotateLeft(curr);
            }
            if (curr != null) {
                curr = curr.right;
            }
        }
    }

    int size() {
        return sizeRec(root);
    }

    int sizeRec(Node root) {
        if (root == null)
            return 0;
        return 1 + sizeRec(root.left) + sizeRec(root.right);
    }

    Node rotateLeft(Node node) {
        if (node == null || node.right == null)
            return node;
        Node rightChild = node.right;
        node.right = rightChild.left;
        rightChild.left = node;
        return rightChild;
    }

    // Função para exibir a árvore in-order
    void inorder() {
        inorderRec(root);
    }

    void inorderRec(Node root) {
        if (root != null) {
            inorderRec(root.left);
            System.out.print(root.data + " ");
            inorderRec(root.right);
        }
    }
}



public class Main {
    public static void main(String[] args) {
        BinaryTree tree = new BinaryTree();
        Random random = new Random();

        for (int i = 0; i < 100; i++) {
            tree.insert(random.nextInt(101));
        }

        System.out.println("Árvore antes do balanceamento:");
        tree.inorder();

        tree.createBalancedTree();

        System.out.println("\n\nÁrvore após o balanceamento inicial:");
        tree.inorder();

        System.out.println("\n\nAdicionando 20 números adicionais:");
        for (int i = 0; i < 20; i++) {
            int num = random.nextInt(101);
            tree.insert(num);
            System.out.print(num + " ");
        }

        System.out.println("\n\nÁrvore após adicionar novos elementos:");
        tree.inorder();

        tree.createBalancedTree();

        System.out.println("\n\nÁrvore após adicionar e rebalancear:");
        tree.inorder();
    }
}
